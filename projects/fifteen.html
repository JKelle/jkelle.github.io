<!DOCTYPE html>
<html>
<head>
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css" />
	<link href="../css/projectPage.css" type="text/css" rel="stylesheet" />
	<link href="../css/mobile.css" type="text/css" rel="stylesheet" media="screen and (max-device-width: 480px)" />
	<meta name="viewport" content="width=device-width" />
</head>
<body>
	
	<h1 style="text-align: center">AI for Classic 15 Tile Game</h1>

	<div style="text-align: center">
		(<a href="https://github.com/JKelle/Fifteen-Puzzle-AI" target="_blank">source on github</a>)
	</div>

	<div id="photos">
		<video height="300" autoplay="autoplay" poster="../assets/Fifteen/scrambled.png" loop>
			<source src="../assets/Fifteen/fifteen_video.mp4" type="video/mp4">
		</video>
	</div>
	
	<div class="container">
		<div class="row">

			<div class="col-sm-3">
			</div>

			<div id="description" class="col-sm-6">
				
				<div class="projectParagraph">
					
					<h4>About the Game</h4>

					<p>
					The goal of the game is to slide the tiles into their correct arrangement. Players can scramble the tiles any number of times before invoking the AI. Or if they prefer, players can manually play the game by clicking tiles.
					</p>
				
				</div>
				
				<div class="projectParagraph">

					<h4>Challenge</h4>

					<p>
					This project focuses on artificial intelligence which solves the game. The main challenge is searching through a <strong>large state space</strong>. There is an average branching factor of 3, so a solution at depth 30 (30 moves) would have more than 100 trillion nodes above it. Basic graph search algorithms like breadth first search and depth first search are too slow. Even A* with a decent heuristic is too slow.
					</p>
				
				</div>
				
				<div class="projectParagraph">
					
					<h4>Solution</h4>

					<p>
					The key to solving the game was to <strong>divide the problem into smaller, more manageable sub-problems</strong>. First, get the top row in the correct place, ignoring the positions of the other tiles. Then from there, get the first two rows in their correct positions, etc. Each sub-problem was solved with A* using a <strong>heuristic</strong> that summed the Manhattan distances between each tile and its respective correct location. Dividing the problem like this dramatically reduces computation time, but it sacrifices optimality.
					</p>
				
				</div>
				
				<div class="projectParagraph">

					<h4>Other Notes</h4>

					<p>
					This solution isn't optimal, but it provides an upper bound on the depth of the optimal solution. I experimented with <strong>depth limited search</strong>, using this upper bound as the depth limit. This too, however, is too slow.
					</p>

				</div>

				<div class="projectParagraph">

					<h4>Technologies & Concepts</h4>
					<ul>
						<li>Python</li>
						<li>Artificial Intelligence</li>
						<li>Graph Search</li>
						<ul>
							<li>A* with heuristic design</li>
							<li>Breadth First Search</li>
							<li>Depth First Search</li>
							<li>Depth Limited Search</li>
							<li>Iterative Deepening Search</li>
						<ul>
					</ul>

				</div>

			</div>

			<div class="col-sm-3">
			</div>

		</div>
	</div>

</body>
</html>

